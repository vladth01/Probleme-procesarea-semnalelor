# -*- coding: utf-8 -*-
"""Lab_2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZgeplGuF9m7qt0ICkiOj-qiulYQgBMZD

**Exercitiile complete din laboratorul 2**
"""

pip install sounddevice

import numpy as np
import matplotlib.pyplot as plt
import scipy.io.wavfile as wav
import sounddevice as sd

"""*Exercitiul 1*"""

# Parametrii semnalului sinusoidal
amplitudine = 1.0
frecventa = 2.0
faza = np.pi / 4  # Un sfert de perioadă

# Cream un vector de timp
timp = np.linspace(0, 2, 1000)  # Intervalul de timp de la 0 la 2 secunde

# Generm semnalul sinusoidal și cosinusoidal
semnal_sinus = amplitudine * np.sin(2 * np.pi * frecventa * timp + faza)
semnal_cosinus = amplitudine * np.cos(2 * np.pi * frecventa * timp + faza)

# Afișați cele două semnale pe subplot-uri diferite
plt.figure(figsize=(10, 6))

plt.subplot(2, 1, 1)
plt.plot(timp, semnal_sinus)
plt.title('Semnal Sinusoidal')
plt.xlabel('Timp (s)')
plt.ylabel('Amplitudine')
plt.grid(True)

plt.subplot(2, 1, 2)
plt.plot(timp, semnal_cosinus)
plt.title('Semnal Cosinusoidal')
plt.xlabel('Timp (s)')
plt.ylabel('Amplitudine')
plt.grid(True)

plt.tight_layout()
plt.show()

"""*Exercitiul 2*"""

# Parametrii semnalului sinusoidal de bază
amplitudine = 1.0
frecventa = 5.0  # Hz
faze = [0, np.pi/4, np.pi/2, 3*np.pi/4]  # 4 valori diferite pentru faza

# Crearea vectorului de timp
timp = np.linspace(0, 1, 1000)  # Intervalul de timp de la 0 la 1 secundă

# Generarea semnalelor sinusoidale cu diferite faze și adăugarea zgomotului
semnal_sinusoidal = []
snr_dorit = [0.1, 1, 10, 100]

for faza in faze:
    semnal_sinus = amplitudine * np.sin(2 * np.pi * frecventa * timp + faza)
    semnal_zgomot = np.random.normal(0, 0.1, len(timp))  # Adăugare de zgomot

    for snr in snr_dorit:
        semnal_final = semnal_sinus + snr * semnal_zgomot
        plt.plot(timp, semnal_final)

plt.title('Semnale sinusoidale cu zgomot adăugat')
plt.xlabel('Timp (s)')
plt.ylabel('Amplitudine')
plt.legend()
plt.grid(True)
plt.show()

"""*Exercitiul 3*"""

# (a) Semnal sinusoidal de 400 Hz cu 1600 de eșantioane
frecventa_a = 400  # Hz
numar_esantioane_a = 1600
timp_a = np.linspace(0, 20, numar_esantioane_a)
semnal_a = np.sin(2 * np.pi * frecventa_a * timp_a)

# (b) Semnal sinusoidal de 800 Hz care durează 3 secunde
frecventa_b = 800  # Hz
durata_b = 3  # secunde
timp_b = np.linspace(0, durata_b, int(frecventa_b * durata_b))
semnal_b = np.sin(2 * np.pi * frecventa_b * timp_b)

# (c) Semnal sawtooth de 240 Hz
frecventa_c = 240  # Hz
timp_c = np.linspace(0, 20, numar_esantioane_a)
semnal_c = 2 * (timp_c * frecventa_c - np.floor(0.5 + timp_c * frecventa_c))

# (d) Semnal square de 300 Hz
frecventa_d = 300  # Hz
timp_d = np.linspace(0, 1, num=100)
semnal_d = np.sign(np.sin(2 * np.pi * frecventa_d * timp_d))

# Afișarea semnalelor
print("Redare semnal sinusoidal de 400Hz cu 1600 de esantioane")
sd.play(semnal_a, frecventa_a)
sd.wait()
print("Redare semnal sinusoidal de 800 hz care dureaza 3 secunde")
sd.play(semnal_b, frecventa_b)
sd.wait()
print("Redare semnal sawtooth de 240 Hz")
sd.play(semnal_c, frecventa_c)
sd.wait()
print("Redare semnal square de 300 Hz")
sd.play(semnal_d, frecventa_d)
sd.wait()

# Salvarea unui semnal ca fișier .wav
wavfile.write('semnal_a.wav', frecventa_a, semnal_a)

"""*Exercitiul 4*"""

# Parametrii semnalului sinusoidal
frecventa_sinus = 2.0  # Hz pentru semnalul sinusoidal
amplitudine_sinus = 1.0

# Parametrii semnalului tip sawtooth
frecventa_sawtooth = 1.0  # Hz pentru semnalul tip sawtooth
amplitudine_sawtooth = 0.5

# Vectorul de timp
timp = np.linspace(0, 2, 1000)  # Intervalul de timp de la 0 la 2 secunde

# Generarea semnalului sinusoidal
semnal_sinus = amplitudine_sinus * np.sin(2 * np.pi * frecventa_sinus * timp)

# Generarea semnalului tip sawtooth
semnal_sawtooth = amplitudine_sawtooth * (timp - np.floor(timp))

# Adunarea celor două semnale
semnal_suma = semnal_sinus + semnal_sawtooth

# Afișarea semnalelor pe grafice separate în subplot-uri
plt.figure(figsize=(10, 6))

plt.subplot(3, 1, 1)
plt.plot(timp, semnal_sinus)
plt.title('Semnal Sinusoidal')
plt.xlabel('Timp (s)')
plt.ylabel('Amplitudine')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(timp, semnal_sawtooth)
plt.title('Semnal Sawtooth')
plt.xlabel('Timp (s)')
plt.ylabel('Amplitudine')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(timp, semnal_suma)
plt.title('Suma Semnalelor')
plt.xlabel('Timp (s)')
plt.ylabel('Amplitudine')
plt.grid(True)

plt.tight_layout()
plt.show()

"""*Exercitiul 5*"""

# Frecvența de eșantionare
fs = 44100  # Hz (frecvența standard pentru audio)

# Vectorul de timp
timp = np.linspace(0, 1, fs, endpoint=False)

# Generarea semnalelor
frecventa1 = 440.0  # Hz pentru primul semnal
frecventa2 = 660.0  # Hz pentru al doilea semnal
semnal1 = 0.5 * np.sin(2 * np.pi * frecventa1 * timp)
semnal2 = 0.5 * np.sin(2 * np.pi * frecventa2 * timp)

# Concatenarea semnalelor într-un singur vector
semnal_final = np.hstack((semnal1, semnal2))

# Salvarea semnalului generat ca fișier audio WAV
wavfile.write('semnal_audio.wav', fs, semnal_final)

# Redarea semnalului generat
rate, semnal_incarcat = wavfile.read('semnal_audio.wav')
sd.play(semnal_incarcat, rate)
sd.wait()

"""*Exercitiul 6*"""

# Frecvența de eșantionare
fs = 8.0  # Hz (alegeți o frecvență de eșantionare suficient de mare)

# Vectorul de timp
timp = np.linspace(0, 1, int(fs), endpoint=False)

# Generarea semnalelor
frecventa_a = fs / 2.0
frecventa_b = fs / 4.0
frecventa_c = 0.0

semnal_a = np.sin(2 * np.pi * frecventa_a * timp)
semnal_b = np.sin(2 * np.pi * frecventa_b * timp)
semnal_c = np.sin(2 * np.pi * frecventa_c * timp)

# Afișarea semnalelor
plt.figure(figsize=(10, 6))
plt.subplot(3, 1, 1)
plt.plot(timp, semnal_a)
plt.title('Semnal cu frecvență fs/2')
plt.xlabel('Timp (s)')
plt.grid(True)

plt.subplot(3, 1, 2)
plt.plot(timp, semnal_b)
plt.title('Semnal cu frecvență fs/4')
plt.xlabel('Timp (s)')
plt.grid(True)

plt.subplot(3, 1, 3)
plt.plot(timp, semnal_c)
plt.title('Semnal cu frecvență 0 Hz')
plt.xlabel('Timp (s)')
plt.grid(True)

plt.tight_layout()
plt.show()

"""Observam că semnalul cu frecvența "fs/2" va arăta o singură oscilație pe intervalul de timp dat, semnalul cu frecvența "fs/4" va avea două oscilații, iar semnalul cu frecvența "0 Hz" va fi constant, fără oscilații, deoarece este o frecvență mai mică sau egală cu cea de eșantionare.

*Exercitiul 7*

*a)*
"""

# Frecvența de eșantionare inițială
fs_initial = 1000.0  # Hz

# Crearea unui semnal sinusoidal la frecvența inițială
timp_initial = np.arange(0, 1, 1/fs_initial)
semnal_initial = np.sin(2 * np.pi * 100.0 * timp_initial)  # Frecvența de 100 Hz

# Decimarea semnalului la 1/4 din frecvența inițială
semnal_decimat = semnal_initial[::4]

# Afișarea celor două semnale
plt.figure(figsize=(10, 6))
plt.subplot(2, 1, 1)
plt.plot(timp_initial, semnal_initial)
plt.title('Semnal initial (Fs = 1000 Hz)')
plt.xlabel('Timp (s)')
plt.grid(True)

# Frecvența de eșantionare a semnalului decimat este 250 Hz
fs_decimat = fs_initial / 4
timp_decimat = np.arange(0, 1, 1/fs_decimat)

plt.subplot(2, 1, 2)
plt.plot(timp_decimat, semnal_decimat)
plt.title('Semnal decimat (Fs = 250 Hz)')
plt.xlabel('Timp (s)')
plt.grid(True)

plt.tight_layout()
plt.show()

"""Semnalul inițial are o frecvență de 100 Hz, iar semnalul decimat are o frecvență de 100 Hz / 4 = 25 Hz. Prin decimare, am obținut o reducere a frecvenței semnalului, ceea ce face ca semnalul decimat să aibă o oscilație mai lentă.

*b)*
"""

# Decimarea semnalului la 1/4 din frecvența inițială, pornind de la al doilea element
semnal_decimat_starting_from_2nd = semnal_initial[1::4]

# Afișarea celor două semnale
plt.figure(figsize=(10, 6))
plt.subplot(2, 1, 1)
plt.plot(timp_initial, semnal_initial)
plt.title('Semnal initial (Fs = 1000 Hz)')
plt.xlabel('Timp (s)')
plt.grid(True)

plt.subplot(2, 1, 2)
plt.plot(timp_decimat, semnal_decimat_starting_from_2nd)
plt.title('Semnal decimat (Fs = 250 Hz), pornind de la al doilea element')
plt.xlabel('Timp (s)')
plt.grid(True)

plt.tight_layout()
plt.show()

"""În acest caz, semnalul decimat pornește de la al doilea eșantion al semnalului inițial. Acest lucru poate afecta faza semnalului, și de aceea observați că semnalul decimat pornind de la al doilea element are o fază diferită față de cel din primul exemplu.

*Exercitiul 8*
"""

# Intervalul de valori pentru α
alpha = np.linspace(-np.pi/2, np.pi/2, 1000)

# Calculul valorilor reale ale sin(α)
real_values = np.sin(alpha)

# Calculul aproximării sin(α) ≈ α
approximation1 = alpha

# Calculul aproximării Pade
approximation2 = (alpha - (7 * alpha ** 3) / 60) / (1 + (alpha ** 2) / 20)

# Calculul erorii dintre valorile reale și cele aproximative
error1 = real_values - approximation1
error2 = real_values - approximation2

# Afișarea graficelor
plt.figure(figsize=(12, 6))

plt.subplot(2, 1, 1)
plt.plot(alpha, real_values, label='sin(α)')
plt.plot(alpha, approximation1, label='α')
plt.plot(alpha, approximation2, label='Approximation Pade')
plt.title('Compararea aproximărilor cu sin(α)')
plt.xlabel('α')
plt.ylabel('Valoare')
plt.legend()
plt.grid(True)

plt.subplot(2, 1, 2)
plt.semilogy(alpha, np.abs(error1), label='Eroare α')
plt.semilogy(alpha, np.abs(error2), label='Eroare Approximation Pade')
plt.title('Eroare logaritmică')
plt.xlabel('α')
plt.ylabel('Eroare (log)')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()